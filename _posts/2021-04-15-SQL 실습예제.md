---
layout: page
title: "SQL 실습예제"
subtitle: "DATABASE"
date: 2021-04-15
background: '/img/posts/01.jpg'
categories: ['Database']
---

![UNION & DISTINCT](/img/posts/UNION & DISTINCT.jpg){: width="100%" height="300"}

-----

```sql
-- LOCAL_SCOTT
SELECT ENAME, JOB, SAL
FROM EMP
UNION
SELECT ENAME AS 이름, JOB, SAL
FROM EMP
;

SELECT ENAME AS 이름, JOB, SAL
FROM EMP
UNION ALL
SELECT ENAME, JOB, SAL
FROM EMP
;

-- 연도별 입사자 수, 월별 입사자 수 데이터
SELECT TO_CHAR(HIREDATE, 'YY') AS D, COUNT(*) AS CNT, 'Y' AS GBN
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'YY'), 'Y'
UNION
SELECT TO_CHAR(HIREDATE, 'MM') AS D, COUNT(*) AS CNT, 'M' AS GBN
FROM EMP
GROUP BY TO_CHAR(HIREDATE, 'MM'), 'M'
;
```

-----

-----

```sql
-- LOCAL_HR
SELECT FIRST_NAME, LAST_NAME, EMAIL,
        SUBSTR(FIRST_NAME, 1, 1) || UPPER(SUBSTR(REPLACE(LAST_NAME,' ', ''), 1, 7)) AS EM
FROM EMPLOYEES
ORDER BY EMPLOYEE_ID ASC
;

-- 사원들이 근무하고 있는 도시를 구하시오.
SELECT DISTINCT L.CITY
FROM LOCATIONS L INNER JOIN DEPARTMENTS D
                        ON L.LOCATION_ID = D.LOCATION_ID
               INNER JOIN (SELECT DISTINCT DEPARTMENT_ID
                           FROM EMPLOYEES) E
                        ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
;

--- 학생들이 낸 문제들 ---
-- IT 부서 사람들의 급여평균을 구하고 전체 사원들 중에 방금 구한 급여평균(IT 부서 사람들의 급여평균)보다 높은 사원들의 급여를 50% 감봉하고 전체 사원의 정보를 출력하시오.
-- 출력 : 사람이름(풀네임), 사는도시, 급여
SELECT E.FIRST_NAME || E.LAST_NAME AS FULL_NAME, E1.CITY,
DECODE(E.EMPLOYEE_ID,178,E.SALARY,E1.급여) AS 급여
FROM EMPLOYEES E LEFT OUTER JOIN (
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, CASE WHEN E.SALARY > A.SAL_AVG
                                THEN E.SALARY * 0.5
                                ELSE E.SALARY
                                END 급여, L.CITY
FROM EMPLOYEES E INNER JOIN (SELECT AVG(SALARY) AS SAL_AVG
                            FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
                                                    ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
                                                    AND DEPARTMENT_NAME = 'IT') A
                        ON 1 = 1 
                INNER JOIN DEPARTMENTS D
                        ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
                INNER JOIN LOCATIONS L
                        ON D.LOCATION_ID = L.LOCATION_ID) E1
                        ON E.EMPLOYEE_ID = E1.EMPLOYEE_ID
ORDER BY E.EMPLOYEE_ID ASC
;

--미국에 근무하는 부서장들 중 급여가 전체 부서장들의 평균 급여 이상인 경우, 해당 부서장의 급여를 10% 삭감하시오.
--(부서장의 LAST_NAME, 기존 연봉, 변경된 연봉을 출력하시오.)
SELECT E.LAST_NAME, E.SALARY,
CASE WHEN E.SALARY >= A.AVG_SAL
THEN E.SALARY * 0.9
ELSE E.SALARY
END AS RSAL
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.EMPLOYEE_ID = D.MANAGER_ID
INNER JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID
INNER JOIN COUNTRIES C
ON L.COUNTRY_ID = C.COUNTRY_ID
AND C.COUNTRY_NAME = 'United States of America'
INNER JOIN (SELECT AVG(E.SALARY) AS AVG_SAL
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.EMPLOYEE_ID = D.MANAGER_ID) A
ON 1 = 1
;

--first name이 a로시작하는 사원들이 거주하는 도시의 개수를 찾아라
SELECT COUNT(*) AS CNT
FROM ( SELECT DISTINCT D.LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.FIRST_NAME LIKE 'A%') A
;

--2005년에 입사한 사람이 있는 부서/기준으로 그 부서에서 2005년 이전에 입사한 사람의 부서명과 부서별로 평균 연봉을 구하시오.
SELECT D.DEPARTMENT_NAME, ROUND(AVG(E.SALARY), 2) AS AVG_SAL
FROM EMPLOYEES E INNER JOIN (SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') = 2005) Y
ON E.DEPARTMENT_ID = Y.DEPARTMENT_ID
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE TO_CHAR(HIRE_DATE, 'YYYY') <= 2005
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
;

--2005년에 입사한 사람이 있는 부서기준으로 그 부서에서 2005년 이전에 입사한 사람만 있는 부서명과 부서별로 평균 연봉을 구하시오.
SELECT D.DEPARTMENT_NAME, ROUND(AVG(E.SALARY), 2) AS AVG_SAL
FROM EMPLOYEES E INNER JOIN (SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') = 2005) Y
ON E.DEPARTMENT_ID = Y.DEPARTMENT_ID
INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.DEPARTMENT_ID NOT IN (SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
WHERE TO_CHAR(HIRE_DATE, 'YYYY') > 2005
AND DEPARTMENT_ID IS NOT NULL)
WHERE TO_CHAR(HIRE_DATE, 'YYYY') <= 2005
GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME
;

--IT 부서 사람들의 급여평균을 구하고 전체 사원들 중에 방금 구한 급여평균(IT 부서 사람들의 급여평균)보다 높은 사원들의 급여를 50% 감봉하고 전체 사원의 정보를 출력하시오.
--출력 : 사람이름(풀네임), 사는도시, 급여, 부서이름
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS FULL_NAME, L.CITY,
CASE WHEN E.SALARY > A.AVG_SAL
THEN E.SALARY * 0.5
ELSE E.SALARY
END AS RSAL, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID
INNER JOIN (SELECT AVG(E.SALARY) AS AVG_SAL
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.DEPARTMENT_NAME = 'IT') A
ON 1 = 1
;

-- 상여금을 포함한 직원들 급여에서 평균을 구하여 평균보다 높은 급여를 받는 직원들의 급여를 20% 감봉시킨다.
-- 급여가 5000초과인 직원들이 가장 많은 부서의 직원을 구하시오
SELECT E.*
FROM EMPLOYEES E INNER JOIN (SELECT E.DEPARTMENT_ID, COUNT(*) AS CNT,
RANK() OVER(ORDER BY COUNT(*) DESC) AS RNK
FROM EMPLOYEES E INNER JOIN (SELECT AVG(SALARY 
+ (SALARY * NVL(COMMISSION_PCT, 0))) AS AVG_SAL
FROM EMPLOYEES) A
ON 1 = 1
WHERE CASE WHEN E.SALARY > A.AVG_SAL
THEN E.SALARY * 0.8
ELSE E.SALARY
END > 5000
GROUP BY E.DEPARTMENT_ID) A
ON E.DEPARTMENT_ID = A.DEPARTMENT_ID
AND A.RNK = 1
;

--South San Francisco에 근무하는 사람들중
--급여가 전체평균급여보다 낮은 사람은 급여를 20%인상하고, 높은사람들의 급여를 20% 낮춰서 
--업무별 최고 연봉과 변경된 급여순위를 성,이름,이메일,급여,근무도시를 포함하여 구하시오
SELECT A.LAST_NAME, A.FIRST_NAME, A.EMAIL, A.RSAL, A.CITY, A.JOB_TITLE, A.MAX_SAL,
RANK() OVER(ORDER BY A.RSAL DESC) AS RNK
FROM ( SELECT E.LAST_NAME, E.FIRST_NAME, E.EMAIL, J.JOB_ID, J.JOB_TITLE, A.MAX_SAL,
CASE WHEN E.SALARY < B.AVG_SAL
THEN E.SALARY * 1.2
WHEN E.SALARY > B.AVG_SAL
THEN E.SALARY * 0.8
ELSE E.SALARY
END AS RSAL, L.CITY
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN LOCATIONS L
ON D.LOCATION_ID = L.LOCATION_ID
AND L.CITY = 'South San Francisco'
INNER JOIN JOBS J
ON E.JOB_ID = J.JOB_ID
INNER JOIN (SELECT JOB_ID, MAX(SALARY) AS MAX_SAL
FROM EMPLOYEES
GROUP BY JOB_ID) A
ON E.JOB_ID = A.JOB_ID
INNER JOIN (SELECT AVG(SALARY) AS AVG_SAL
FROM EMPLOYEES E) B
ON 1 = 1) A
;
```

